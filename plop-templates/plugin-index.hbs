/**
 * {{pascalCase name}} Plugin
 * Implements BlockchainProvider for {{pascalCase name}} wallet generation
 */

import * as qrcode from "qrcode-terminal";
import {
  BlockchainProvider,
  PluginMetadata,
  WalletInfo,
} from "../../core/interfaces";

class {{pascalCase name}}Provider implements BlockchainProvider {
  readonly metadata: PluginMetadata = {
    id: "{{kebabCase name}}",
    name: "{{pascalCase name}}",
    symbol: "{{upperCase symbol}}",
    icon: "{{icon}}",
    version: "1.0.0",
    description: "{{description}}",
    author: "{{author}}",
    {{#if derivationPath}}
    derivationPath: "{{{derivationPath}}}",
    {{/if}}
  };

  /**
   * Generate a wallet from the provided seed
   * 
   * @param seed - The BIP39 seed buffer (64 bytes)
   * @returns WalletInfo object containing address, private key, and public key
   */
  generateWallet(seed: Buffer): WalletInfo {
    // TODO: Implement your wallet generation logic here
    // 
    // Example:
    // const wallet = yourBlockchainLib.fromSeed(seed);
    // 
    // return {
    //   address: wallet.address,
    //   privateKey: wallet.privateKey.toString("hex"),
    //   publicKey: wallet.publicKey.toString("hex"),
    // };

    throw new Error("{{pascalCase name}} wallet generation not yet implemented");
  }

  /**
   * Get the blockchain explorer URL for an address
   */
  getExplorerUrl(address: string): string {
    return `{{explorerUrl}}/${address}`;
  }

  /**
   * Format wallet information for display
   */
  async formatWalletInfo(wallet: WalletInfo): Promise<string[]> {
    const lines: string[] = [];

    lines.push(
      `${this.metadata.icon}  ${this.metadata.name.toUpperCase()} (${
        this.metadata.symbol
      })`
    );
    lines.push("-".repeat(80));
    lines.push(`Address:     ${wallet.address}`);
    lines.push(`Explorer:    ${this.getExplorerUrl(wallet.address)}`);
    lines.push("");
    lines.push("QR Code:");

    const qrCode = await this.generateQRCode(wallet.address);
    lines.push(qrCode);

    lines.push("");
    lines.push(`Private Key: ${wallet.privateKey}`);
    lines.push(`Public Key:  ${wallet.publicKey}`);
    lines.push("");

    return lines;
  }

  /**
   * Validate if an address is valid for this blockchain
   */
  validateAddress(address: string): boolean {
    // TODO: Implement address validation
    // Example: return /^[a-zA-Z0-9]{32,64}$/.test(address);
    return true;
  }

  /**
   * Helper method to generate QR code
   */
  private generateQRCode(data: string): Promise<string> {
    return new Promise((resolve) => {
      let qrString = "";
      qrcode.generate(data, { small: true }, (qr) => {
        qrString = qr;
        resolve(qrString);
      });
    });
  }
}

// Export provider instance
export const provider = new {{pascalCase name}}Provider();
export default provider;

